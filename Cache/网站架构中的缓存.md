## 网站架构中的缓存
> ![image](https://note.youdao.com/yws/api/personal/file/F0430B67472F4B11B8577A56CC026CA4?method=download&shareKey=8d33adf1c1a85fbb1ed7c5d80c67f852)
>
> #### 网站架构缓存如图可分为：
> > #### 客户端缓存
> > > - 页面缓存
> > >  > 将之前渲染的页面保存为文件，当用户再次访问时可以避开网络连接，从而减少负载，提升性能和用户体验。
> > > - 浏览器缓存
> > >
> > > > HTTP1.0：与服务器约定规则进行，在服务器侧设置Expires的HTTP头来告诉客户端在重新请求文件之前多久是安全的，可以使用if-midified-since的条件请求来清空缓存，比较文件最初的下载时间和最后的更新时间，如果文件没有改变可以用304-Not Modified应答客户端
> > > >
> > > > HTTP1.1：缓存系统被形式化引入了e-Tag标签，e-Tag标签是文件或者对象的唯一标识，当询问服务器某一个资源的e-Tag标签是否有效，有效会生成304-Not Modified；否则返回200提供正确的文件
> > > >
> > > > ![e-Tag流程图](https://note.youdao.com/yws/api/personal/file/WEBb567791a999bb7f27b16a79d0c258432?method=download&shareKey=d9fe97b682b4e9bcef1909cd8093a87f)
> > > >
> > > > Cache-Control/Expires和Last-Modified/ETag一期使用时，Cache-Control/Expires的优先级要高于后者。即当本地缓存根据Cache-Control/Expires判断还在有效期内时，就不会在去服务器询问修改时间和实体标识了。
> > > >
> > > > 在html页面可以添加（并不是所有浏览器都支持）
> > > >
> > > > ```html
> > > > <META HTTP-EQUIV="Pragma" CONTENT="no-cache">
> > > > ```
> > >
> > > - APP上缓存
> > >
> > > > 数据库缓存：把文件的相关信息（URL、路径、下载时间、过期时间）等放到数据库中，下次查询先从数据库中查询做对比
> > > >
> > > > 文件缓存：使用文件操作的API获取文件的最后修改时间。图片和其他配置类文件的缓存时间不一样。图片的缓存时间可能可以持续到下次清空缓存，但是配置文件可能会被更新；在不同网络环境下缓存的更新时间也可以不一样
> > #### 网络中缓存
> > > - WEB代理缓存
> > >
> > > > 正向代理
> > > >
> > > > 反向代理：客户端向代理服务发送请求，反向代理自己判断向何处发送请求，然后将从源服务获取到的内容返回给客户端
> > > >
> > > > 透明代理：客户端根本不需要知道有代理服务器的存在，又代理服务器改变客户端的请求报文，并传送真实的IP地址
> > > >
> > > > 匿名代理：加密的透明代理
> > >
> > > - 边缘缓存
> > >
> > > > 反向代理服务和用户来源于同一个网络，用户访问反向代理服务就会得到较高质量的响应，这种反向代理缓存叫做边缘缓存
> > > >
> > > > 边缘缓存的商业化服务-CDN
> > > >
> > > > CDN缓存也是通过HTTP响应头的Cache-Control:max-age字段来设置CDN边缘节点的数据缓存时间，当客户端向CDN节点请求数据时，CDN回先判断缓存时间是否过期，没有过期则将缓存返回给客户端，过期则像服务器请求数据并更新本地缓存。
> > #### 服务端缓存
> > > - 数据库缓存
> > >
> > > > query cache：作用于MySQL实例，主要针对于select语句，MySQL将接收到的select语句以字符串进行hash，然后在query cache中进行查找，如果有就返回query cache的内容。
> > > >
> > > > query cache：需要query_cache_size和query_cache_type；前者设置缓存大小，后者表示在那种场景下使用（0-OFF，1-ON，2-DEMAND）
> > > >
> > > > Qcache inserts表示多少次未命中然后插入；Qcache lowmem prunes值大则说明缓存不够；Qcache hits值非常大，则说明使用缓存较频繁；Qcache free blocks表明缓存区的碎片，如果较多需要清理.	
> > >
> > > > InnoDB缓存：innodb_buffer_pool_size设置缓存InnoDB索引及数据块的内存区域大小；table_cache设置高速缓存的数量。
> > >
> > > - 平台级缓存
> > >
> > > > EhCache：
> > > >
> > > > > - 轻量快速：线程机制为大型高并发系统设计
> > > > > - 良性伸缩：数据可以伸缩到数G字节，节点可以到数百个
> > > > > - 简洁灵活：运行时缓存设置，存活时间、空闲时间、内存和缓存存放的最大数目可以在运行时修改
> > > > > - 标准支持：
> > > > > - 强扩展性：节点发现，冗余器和监听器可插件化
> > > > > - 数据持久：缓存的数据在机器重启后可以在磁盘上获取
> > > > > - 缓存监听：提供对缓存事件之后的处理机制
> > > > > - 分布式缓存：支持高性能的分布式缓存，兼具灵活性和扩展性
> > >
> > > - 应用级缓存
> > >
> > > > Redis：
> > >
> > > > 应用缓存技术：
> > > >
> > > > - 缓存命中：缓存中有这一对象，则使用缓存的数据
> > > > - 没有命中：cache miss ，缓存中还有空间的时候，没有命中的对象就会被放入缓存中
> > > > - 存储成本：没有命中缓存，需要从数据库中取出数据放入缓存，这个过程消耗的时间和空间叫做存储成本
> > > > - 缓存失效：存储在缓存中的数据要被更新时，则原数据就失效了
> > > > - 替代策略：当缓存已经满了，有新的数据来，需要从缓存中去除一条旧的数据放入新的数据，如何去除如何插入新的需要有替代策略
> > >
> > > > 替代策略：
> > > >
> > > > - Least-Recently-Used（LRU）：替换掉最近最少请求的对象
> > > > - Least-Frequently-Used（LFU）：替换掉访问次数最少的对象
> > > > - Least-Recently-Used 2（LRU2）：把最近访问两次的对象放入缓存，会把最近两次使用最少的缓存对象去除，需要跟踪对象两次，访问负载会增加
> > > > - Two  Queues（2Q）：把被访问的数据放到KRU的缓存中，如果这个对象在被访问一次，就把这个对象放到第二个、更大的LRU缓存中，使用多级缓存
> > > > - SIZE：替换占用空间最大的对象，这样会导致某些小对象可能一直存在与缓存中
> > > > - LRU-Threshold：不缓存超过某一大小的对象，其他与LRU相同
> > > > - Log(size)+LRU：替换最大的对象，size相同时按照LRU处理
> > > > - Hyper-G：LFU的改进，同时考虑上一次访问时间和大小
> > > > - Pitkow/Recker：替换最近最少使用的对象，除非所有对象都是今天使用的；如果都是今天则替换掉最大的对象
> > > > - Lowest-Latency-First：替换下载时间最少的文件
> > > > - Hybrid Hybrid：减少平均延迟，对缓存中的每个文档计算一个保留效用，保留效用最小的对象会被替换掉
> > > > - Lowest Relative Value（LRV）：计算保留效用，替换保留效用最低的对象
> > > > - Adaptive Replacement Cache（APC）：介于LRU和LFU中间，由两个LRU组成，第一个LRU包含最近只被使用过一次的，第二个包含最近被使用过两次的，以此得到新的和常用的对象；APC可以自我调节，访问负载较小
> > > > - Most Recently Used（MRU）：MRU与LRU是相对的，移除最近被最多使用的对象；（减少因为计算寻找最少最近的耗时）
> > > > - First in First out（FIFO）：通过队列跟踪缓存对象，最先进入的对象最先被踢走
> > > > - Random Cache：随意替换，效果比FIFO好，有些情况比LRU好
> > >
> > > > 云缓存服务：动态扩容、数据多备、自动容灾、成本较低